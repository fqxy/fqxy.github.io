<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[keras-graphviz]]></title>
    <url>%2F2019%2F03%2F07%2Fkeras-graphviz%2F</url>
    <content type="text"><![CDATA[解决keras模型可视化的问题 问题 在运行Keras框架上的可视化代码时，遇到如下问题： 1OSError: pydot failed to call GraphViz.Please install GraphViz (https://www.graphviz.org/) and ensure that its executables are in the $PATH. 解决 安装相关模块： 123pip install pydot-ng pip install graphviz pip install pydot==1.2.3 下载文件：raphviz-2.38.msi 下载完成后直接安装到自己的指定目录，然后将其bin目录添加到环境变量 完成]]></content>
  </entry>
  <entry>
    <title><![CDATA[float-double]]></title>
    <url>%2F2019%2F03%2F04%2Ffloat-double%2F</url>
    <content type="text"><![CDATA[C语言中float和double的精度问题 总体原则 printf(&quot;%3.0f&quot;,floatNum)：不保留小数 说明：%3.0f表明待打印的浮点数（floatNum）至少占3个字符宽，且不带小数点和小数部分，整数部分至少占3个位宽； 注意：这里的3只代表整数部分至少占3位，舍弃小数点和小数点后面的部分 printf(&quot;%6.2f&quot;.floatNum)：保留两位小数 说明：%6.2f 表明待打印的数（floatNum）至少占6个字符宽度（包括两位小数和一个小数点），且小数点后面有2位小数，小数点占一位，所以整数部分至少占3位。 注意：这里的6是待打印的数至少占据的字符宽度，包括两位小数（如果小数不够两位用0补位，例如100.1打印出来为100.10）和一个小数点，所以整数部分至少占3个字符宽度。 单精度实数的有效位数一般为7位，输出6位小数，超出有效位数输出就是错误的。 双精度数有效位数一般为16位，输出6位小数，超出有效位数可能截断或错误值。 保留小数点后有效位数四舍五入原则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; double a = 0.2; double b = 0.4; double c = a + b; double d = a - b; cout &lt;&lt; "a + b = " &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "a - b = " &lt;&lt; d &lt;&lt; endl; printf("%lf\n", a); printf("%lf\n", c); // 不保留小数 printf("%f\n", 100.00); printf("%.0f\n", 100.00); printf("\n"); // 不保留小数 printf("%f\n", 100.30); printf("%.0f\n", 100.30); printf("\n"); // 不保留小数，四舍五入 printf("%f\n", 100.50); printf("%.0f\n", 100.50); printf("\n"); // 保留一位小数 printf("%f\n", 100.53); printf("%.1f\n", 100.53); printf("\n"); // 保留一位小数，没有四舍五入 printf("%f\n", 100.55); printf("%.1f\n", 100.55); printf("\n"); // 保留1位小数，四舍五入 printf("%f\n", 100.56); printf("%.1f\n", 100.56); printf("\n"); // “四舍六入五留双”。 GCC用的正是这种 printf("%f\n", 100.563); printf("%.2f\n", 100.563); printf("\n"); printf("%f\n", 100.565); printf("%.2f\n", 100.565); printf("\n"); printf("%f\n", 100.566); printf("%.2f\n", 100.566); printf("\n"); return 0;&#125; 输出123456789101112131415161718192021222324252627282930a + b = 0.6a - b = -0.20.2000000.600000100.000000100100.300000100100.500000100100.530000100.5100.550000100.5100.560000100.6100.563000100.56100.565000100.56100.566000100.57]]></content>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook]]></title>
    <url>%2F2019%2F02%2F14%2Fjupyter-notebook%2F</url>
    <content type="text"><![CDATA[如何美化jupyter notebook 主题 首先是主题下载，命令行如下所示： 1pip install --no-dependencies jupyterthemes==0.18.2 有的电脑可能会提示缺少 lesscpy，继续 pip 安装 1pip install lesscpy 使用方法12345jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-vim] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout] [-P] [-T] [-N] [-r] [-dfonts] cl options arg default Usage help -h – List Themes -l – Theme Name to Install -t – Code Font -f – Code Font-Size -fs 11 Notebook Font -nf – Notebook Font Size -nfs 13 Text/MD Cell Font -tf – Text/MD Cell Fontsize -tfs 13 Pandas DF Fontsize -dfs 9 Output Area Fontsize -ofs 8.5 Mathjax Fontsize (%) -mathfs 100 Intro Page Margins -m auto Cell Width -cellw 980 Line Height -lineh 170 Cursor Width -cursw 2 Cursor Color -cursc – Alt Prompt Layout -altp – Alt Markdown BG Color -altmd – Alt Output BG Color -altout – Style Vim NBExt* -vim – Toolbar Visible -T – Name &amp; Logo Visible -N – Kernel Logo Visible -kl – Reset Default Theme -r – Force Default Fonts -dfonts – 我的 1jt -t monokai -f consolamono -fs 14 -tf consolamono -nfs 14 -tfs 14 -ofs 14 -cellw 1200 --lineh 140 -T -N 补全 安装 nbextensions 12pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --user 安装 nbextensions_configurator 12pip install jupyter_nbextensions_configuratorjupyter nbextensions_configurator enable --user 缺少依赖，则使用pip安装 重启jupyter，打开Nbextensions标签页，勾选Hinterland]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow-gpu]]></title>
    <url>%2F2019%2F02%2F10%2Ftensorflow-gpu%2F</url>
    <content type="text"><![CDATA[如何在win10上装tensorflow-gpu 简要介绍 笔记本电脑：小米Air 13.3(i5-8250U) 平台：Windows10 显卡：MX150 python3.6：Anaconda tensorflow-gpu 1.8.0 CUDA Toolkit 9.2 (May 2018) cuDNN v7.2.1 (August 7, 2018), for CUDA 9.2 我的MX150不支持CUDA 9.0，所以用了CUDA 9.2，而且还得用别人编译好的tensorflow Anaconda 环境变量 C:\Users\fq\Anaconda3 C:\Users\fq\Anaconda3\Library\mingw-w64\bin C:\Users\fq\Anaconda3\Library\usr\bin C:\Users\fq\Anaconda3\Library\bin C:\Users\fq\Anaconda3\Scripts 相关命令1234567891011121314151617181920# 配置清华镜像库conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes# 创建环境conda create -n tf python=3.6# 激活环境activate tf# 删除环境conda env remove -n tf# 升级pippython -m pip install --upgrade pip# 安装numpy、matplotlib、scikit-learnpip install numpypip install matplotlibpip install scikit-learn 用 conda install ~ 安装相应的包时会有些问题 tensorflow 下载得到tensorflow_gpu-1.8.0-cp36-cp36m-win_amd64.whl 在cmd中进入tf环境pip install C:\dev\python_wheel\tensorflow_gpu-1.8.0-cp36-cp36m-win_amd64.whl 检验 1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode+cmake+opencv]]></title>
    <url>%2F2019%2F02%2F10%2Fvscode-cmake-opencv%2F</url>
    <content type="text"><![CDATA[记录安装过程 简要介绍 平台：Windows10 编辑器：vscode 编程语言：C++ 编译器：mingw64 组织框架：cmake-3.7.2-win64-x64 视觉库：OpenCV 3.4.1-x64 mingw64安装前 下载 安装选项： Version : 8.1.0 Architecture : ×86_64 Threads : poxis Exception : seh Build revision : 0 安装后 下载好将bin目录加入环境变量，我的是C:\dev\MinGW\mingw64\bin 将bin目录中的mingw32-make.exe拷贝一份重命名为make.exe 这样可以直接在终端使用 在我的C:\dev\MinGW\mingw64\bin中发现有gcc、g++、gdb 在终端中输入gcc、g++、gdb会有反应 cmake 下载 下载好将bin目录加入环境变量，我的是C:\dev\cmake-3.7.2-win64-x64\bin 这样可以直接在终端使用 OpenCV方法一：用别人编译好的opencv：OpenCV-MinGW-Build 方法二：自己用cmake编译opencv源代码 我采用的是方法一 下载好将bin目录加入环境变量，我的是C:\dev\OpenCV-MinGW-Build\x64\mingw\bin 有时间再讲如何自己编译 因此，加入环境变量的有mingw64、cmake、OpenCV vscode和C++工程目录工程目录123456789│├─.vscode| c_cpp_properties.json│ launch.json│ tasks.json|└─ CMakeLists.txt test.cpp test.jpg .vscode里的3个文件这3个文件中只有json c_cpp_properties.json是必须的，后两个可以先不用 json c_cpp_properties.jsonjson c_cpp_properties.json的主要作用是找到相关头文件、找到编译器 includePath改为编译好的opencv中的include目录，我的是C:/dev/OpenCV-MinGW-Build/include compilerPath改为编译器所在位置，我的是C:/dev/MinGW/mingw64/bin/g++ c_cpp_properties.json12345678910111213141516171819202122&#123; "configurations": [ &#123; "name": "Win32", "includePath": [ "$&#123;workspaceFolder&#125;/**", "C:/dev/OpenCV-MinGW-Build/include", "C:/dev/OpenCV-MinGW-Build/include/opencv2" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "compilerPath": "C:/dev/MinGW/mingw64/bin/g++", "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "msvc-x64" &#125; ], "version": 4&#125; launch.jsonlaunch.json的主要作用是进行调试的设置 launch.json123456789101112131415161718192021222324252627&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/build/bin/hello", // 可执行文件位置 "miDebuggerPath": "C:/dev/MinGW/mingw64/bin/gdb.exe", // gdb 位置 "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "preLaunchTask": "compile", // task.json 中的 label "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ]&#125; tasks.jsontasks.json的主要作用是在调试前进行编译，实现自动化 tasks.json1234567891011121314&#123; "version": "2.0.0", "tasks": [ &#123; "label": "compile", "type": "shell", "command": "build.bat", "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ]&#125; 源代码test.cpp12345678910111213141516171819202122232425#include &lt;iostream&gt;# include "opencv2/opencv.hpp"using namespace cv;using namespace std;int main() &#123; Mat image; image = imread("../test.jpg", IMREAD_COLOR); // Read the file namedWindow("Display window", WINDOW_AUTOSIZE); // Create a window for display. if (!image.data) // Check for invalid input &#123; cout &lt;&lt; "Could not open or find the image" &lt;&lt; std::endl; &#125; else &#123; imshow("Display window", image); // Show our image inside it. &#125; waitKey(0); return 0;&#125; CMakeLists.txt 需要将OpenCV_DIR修改为OpenCVConfig.cmake所在目录 我的OpenCVConfig.cmake在C:/dev/OpenCV-MinGW-Build/x64/mingw/lib里面 通过换不同的OpenCVConfig.cmake可以实现不同版本OpenCV的切换 CMakeLists.txt我的github1234567891011cmake_minimum_required(VERSION 2.8)project(effective-opencv)set(OpenCV_DIR "C:/dev/OpenCV-MinGW-Build/x64/mingw/lib")find_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)add_executable(test test.cpp)target_link_libraries(test $&#123;OpenCV_LIBS&#125;)]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sheep]]></title>
    <url>%2F2019%2F02%2F08%2Fsheep%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 这是一个实例链接12345678910111213141516def confirmHSV(img, points): # 转成HSV格式并且滤波 imgHSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # 高斯滤波 blurHSV = cv2.GaussianBlur(imgHSV, (21, 21), 0) BGRs = [] HSVs = [] for point in points: x = point[1] y = point[0] bgr = list(img[x, y]) # hsv = list(cv2.cvtColor(np.uint8([[bgr]]), cv2.COLOR_BGR2HSV)[0][0]) hsv = list(blurHSV[x, y]) default primary success info warning danger 选项卡 1选项卡 2选项卡 3这是选项卡 1 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……这是选项卡 2这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～ 点击下载百度]]></content>
  </entry>
</search>
